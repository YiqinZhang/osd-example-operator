apiVersion: argoproj.io/v1alpha1
kind: WorkflowTemplate
metadata:
  name: osd-example-operator-deployment
  namespace: argo-workflows
  labels:
    app: osd-example-operator
    version: v1.0.0
    team: sre
spec:
  entrypoint: deploy-pipeline
  arguments:
    parameters:
    - name: app-name
      value: "osd-example-operator"
    - name: app-version
      value: "latest"
    - name: image-registry
      value: "quay.io/app-sre"
    - name: image-name
      value: "osd-example-operator"
    - name: image-tag
      value: "latest"
    - name: int-replicas
      value: "1"
    - name: stage-replicas
      value: "2"
    - name: prod-replicas
      value: "3"
    - name: slack-webhook
      value: ""
    - name: notification-webhook
      value: ""
    - name: approver-email
      value: "sre-team@redhat.com"
    - name: enable-notifications
      value: "false"
    - name: enable-approval
      value: "true"


  # Global failure handling
  onExit: notify-on-exit

    templates:
  # Main deployment pipeline
  - name: deploy-pipeline
    steps:
    # Step 1: Send start notification (if enabled)
    - - name: notify-start
        template: send-notification
        arguments:
          parameters:
          - name: message
            value: "üöÄ Starting deployment pipeline for {{workflow.parameters.app-name}} v{{workflow.parameters.app-version}}"
          - name: status
            value: "started"
          - name: color
            value: "good"
        when: "{{workflow.parameters.enable-notifications}} == 'true'"

    # Step 2: Deploy to INT environment
    - - name: deploy-to-int
        template: deploy-app
        arguments:
          parameters:
          - name: environment
            value: "int"
          - name: app-name
            value: "{{workflow.parameters.app-name}}"
          - name: app-version
            value: "{{workflow.parameters.app-version}}"
          - name: image-url
            value: "{{workflow.parameters.image-registry}}/{{workflow.parameters.image-name}}:{{workflow.parameters.image-tag}}"
          - name: replicas
            value: "{{workflow.parameters.int-replicas}}"

    # Step 3: Run E2E tests in INT
    - - name: run-e2e-tests
        template: execute-e2e-tests
        arguments:
          parameters:
          - name: environment
            value: "int"
          - name: app-name
            value: "{{workflow.parameters.app-name}}"
          - name: app-version
            value: "{{workflow.parameters.app-version}}"
          - name: image-url
            value: "{{workflow.parameters.image-registry}}/{{workflow.parameters.image-name}}:{{workflow.parameters.image-tag}}"

    # Step 4: Notify E2E success (if notifications enabled)
    - - name: notify-e2e-success
        template: send-notification
        arguments:
          parameters:
          - name: message
            value: "‚úÖ E2E tests passed for {{workflow.parameters.app-name}} v{{workflow.parameters.app-version}} in INT"
          - name: status
            value: "e2e-passed"
          - name: color
            value: "good"
        when: "{{workflow.parameters.enable-notifications}} == 'true'"

    # Step 5: Manual approval gate (if approval enabled)
    - - name: approval-gate
        template: manual-approval
        arguments:
          parameters:
          - name: approval-message
            value: "E2E tests passed for {{workflow.parameters.app-name}} v{{workflow.parameters.app-version}}. Approve deployment to STAGE?"
          - name: approver
            value: "{{workflow.parameters.approver-email}}"
        when: "{{workflow.parameters.enable-approval}} == 'true'"

    # Step 7: Deploy to STAGE environment
    - - name: deploy-to-stage
        template: deploy-app
        arguments:
          parameters:
          - name: environment
            value: "stage"
          - name: app-name
            value: "{{workflow.parameters.app-name}}"
          - name: app-version
            value: "{{workflow.parameters.app-version}}"
          - name: image-url
            value: "{{workflow.parameters.image-registry}}/{{workflow.parameters.image-name}}:{{workflow.parameters.image-tag}}"
          - name: replicas
            value: "{{workflow.parameters.stage-replicas}}"

    # Step 8: Validate STAGE deployment
    - - name: validate-stage
        template: validate-deployment
        arguments:
          parameters:
          - name: environment
            value: "stage"
          - name: app-name
            value: "{{workflow.parameters.app-name}}"
        when: "{{workflow.parameters.enable-approval}} == 'true'"

    # Step 6: Final success notification (if enabled)
    - - name: notify-success
        template: send-notification
        arguments:
          parameters:
          - name: message
            value: "üéâ Successfully deployed {{workflow.parameters.app-name}} v{{workflow.parameters.app-version}} to INT and STAGE!"
          - name: status
            value: "completed"
          - name: color
            value: "good"
        when: "{{workflow.parameters.enable-notifications}} == 'true'"

  # Application deployment template
  - name: deploy-app
    inputs:
      parameters:
      - name: environment
      - name: app-name
      - name: app-version
      - name: image-url
      - name: replicas
    script:
      image: quay.io/openshift/origin-cli:latest
      command: [bash]
      env:
      - name: KUBECONFIG
        value: /tmp/kubeconfig/kubeconfig
      - name: ENVIRONMENT
        value: "{{inputs.parameters.environment}}"
      resources:
        limits:
          cpu: 500m
          memory: 512Mi
        requests:
          cpu: 100m
          memory: 256Mi
      volumeMounts:
      - name: kubeconfig
        mountPath: /tmp/kubeconfig
        readOnly: true
      securityContext:
        runAsNonRoot: true
        allowPrivilegeEscalation: false
        readOnlyRootFilesystem: false
        capabilities:
          drop:
          - ALL
      source: |
        set -euo pipefail
        echo "=== Deploying {{inputs.parameters.app-name}} to {{inputs.parameters.environment}} ==="
        echo "Version: {{inputs.parameters.app-version}}"
        echo "Replicas: {{inputs.parameters.replicas}}"

        # Verify kubeconfig is mounted
        if [ ! -f "${KUBECONFIG}" ]; then
          echo "‚ùå Kubeconfig not found at ${KUBECONFIG}"
          exit 1
        fi

        echo "üìã Testing cluster connectivity..."
        oc version --client

        if ! oc cluster-info &>/dev/null; then
          echo "‚ùå Cannot connect to cluster"
          exit 1
        fi

        echo "‚úÖ Connected to cluster successfully"

        NAMESPACE="{{inputs.parameters.app-name}}-{{inputs.parameters.environment}}"
        echo "üèóÔ∏è  Target namespace: ${NAMESPACE}"

        # Create namespace
        cat <<EOF | oc apply -f -
        apiVersion: v1
        kind: Namespace
        metadata:
          name: ${NAMESPACE}
          labels:
            app: {{inputs.parameters.app-name}}
            environment: {{inputs.parameters.environment}}
            version: {{inputs.parameters.app-version}}
            managed-by: argo-workflows
        EOF

        # Set environment-specific log level
        if [ "{{inputs.parameters.environment}}" = "prod" ]; then
          LOG_LEVEL="WARN"
        else
          LOG_LEVEL="INFO"
        fi

        # Create ConfigMap
        cat <<EOF | oc apply -f -
        apiVersion: v1
        kind: ConfigMap
        metadata:
          name: {{inputs.parameters.app-name}}-config
          namespace: ${NAMESPACE}
          labels:
            app: {{inputs.parameters.app-name}}
            environment: {{inputs.parameters.environment}}
            version: {{inputs.parameters.app-version}}
        data:
          app.properties: |
            app.name={{inputs.parameters.app-name}}
            app.version={{inputs.parameters.app-version}}
            app.environment={{inputs.parameters.environment}}
            app.replicas={{inputs.parameters.replicas}}
            deployment.timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          logging.conf: |
            level=${LOG_LEVEL}
            format=json
        EOF

        # Create ServiceAccount
        cat <<EOF | oc apply -f -
        apiVersion: v1
        kind: ServiceAccount
        metadata:
          name: {{inputs.parameters.app-name}}
          namespace: ${NAMESPACE}
          labels:
            app: {{inputs.parameters.app-name}}
            environment: {{inputs.parameters.environment}}
        EOF

        # Create ClusterRole
        cat <<EOF | oc apply -f -
        apiVersion: rbac.authorization.k8s.io/v1
        kind: ClusterRole
        metadata:
          name: {{inputs.parameters.app-name}}
          labels:
            app: {{inputs.parameters.app-name}}
            environment: {{inputs.parameters.environment}}
        rules:
        - apiGroups: ["managed.openshift.io"]
          resources: ["examples"]
          verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
        - apiGroups: [""]
          resources: ["events"]
          verbs: ["create", "patch"]
        - apiGroups: [""]
          resources: ["configmaps", "secrets"]
          verbs: ["get", "list", "watch"]
        EOF

        # Create ClusterRoleBinding
        cat <<EOF | oc apply -f -
        apiVersion: rbac.authorization.k8s.io/v1
        kind: ClusterRoleBinding
        metadata:
          name: {{inputs.parameters.app-name}}
          labels:
            app: {{inputs.parameters.app-name}}
            environment: {{inputs.parameters.environment}}
        roleRef:
          apiGroup: rbac.authorization.k8s.io
          kind: ClusterRole
          name: {{inputs.parameters.app-name}}
        subjects:
        - kind: ServiceAccount
          name: {{inputs.parameters.app-name}}
          namespace: ${NAMESPACE}
        EOF

        # Create Service
        cat <<EOF | oc apply -f -
        apiVersion: v1
        kind: Service
        metadata:
          name: {{inputs.parameters.app-name}}
          namespace: ${NAMESPACE}
          labels:
            app: {{inputs.parameters.app-name}}
            environment: {{inputs.parameters.environment}}
        spec:
          selector:
            app: {{inputs.parameters.app-name}}
          ports:
          - name: http
            port: 8080
            targetPort: 8080
          - name: webhook
            port: 8443
            targetPort: 8443
          type: ClusterIP
        EOF

        # Deploy application
        cat <<EOF | oc apply -f -
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: {{inputs.parameters.app-name}}
          namespace: ${NAMESPACE}
          labels:
            app: {{inputs.parameters.app-name}}
            environment: {{inputs.parameters.environment}}
            version: {{inputs.parameters.app-version}}
        spec:
          replicas: {{inputs.parameters.replicas}}
          strategy:
            type: RollingUpdate
            rollingUpdate:
              maxUnavailable: 0
              maxSurge: 1
          selector:
            matchLabels:
              app: {{inputs.parameters.app-name}}
          template:
            metadata:
              labels:
                app: {{inputs.parameters.app-name}}
                environment: {{inputs.parameters.environment}}
                version: {{inputs.parameters.app-version}}
            spec:
              containers:
              - name: {{inputs.parameters.app-name}}
                image: {{inputs.parameters.image-url}}
                ports:
                - containerPort: 8080
                  name: http
                - containerPort: 8443
                  name: webhook
                env:
                - name: WATCH_NAMESPACE
                  value: ""
                - name: POD_NAME
                  valueFrom:
                    fieldRef:
                      fieldPath: metadata.name
                - name: OPERATOR_NAME
                  value: {{inputs.parameters.app-name}}
                livenessProbe:
                  httpGet:
                    path: /healthz
                    port: 8081
                  initialDelaySeconds: 15
                  periodSeconds: 20
                readinessProbe:
                  httpGet:
                    path: /readyz
                    port: 8081
                  initialDelaySeconds: 5
                  periodSeconds: 10
                resources:
                  requests:
                    cpu: 100m
                    memory: 128Mi
                  limits:
                    cpu: 500m
                    memory: 512Mi
                securityContext:
                  runAsNonRoot: true
                  allowPrivilegeEscalation: false
                  readOnlyRootFilesystem: true
                  capabilities:
                    drop:
                    - ALL
                volumeMounts:
                - name: tmp
                  mountPath: /tmp
              serviceAccountName: {{inputs.parameters.app-name}}
              securityContext:
                runAsNonRoot: true
                seccompProfile:
                  type: RuntimeDefault
              volumes:
              - name: tmp
                emptyDir: {}
                  limits:
                    cpu: 200m
                    memory: 256Mi
                env:
                - name: APP_NAME
                  value: {{inputs.parameters.app-name}}
                - name: APP_VERSION
                  value: {{inputs.parameters.app-version}}
                - name: ENVIRONMENT
                  value: {{inputs.parameters.environment}}
                volumeMounts:
                - name: config
                  mountPath: /app/config
                readinessProbe:
                  exec:
                    command: ["cat", "/app/config/app.properties"]
                  initialDelaySeconds: 5
                  periodSeconds: 10
                livenessProbe:
                  exec:
                    command: ["ls", "/app/config"]
                  initialDelaySeconds: 15
                  periodSeconds: 20
              volumes:
              - name: config
                configMap:
                  name: {{inputs.parameters.app-name}}-config
        EOF

        echo "‚è≥ Waiting for deployment to be ready..."
        if ! oc wait --for=condition=Available --timeout=300s deployment/{{inputs.parameters.app-name}} -n "${NAMESPACE}"; then
          echo "‚ùå Deployment failed"
          oc get events -n "${NAMESPACE}" --sort-by='.lastTimestamp'
          exit 1
        fi

        echo "‚úÖ Deployment to {{inputs.parameters.environment}} completed!"

    volumes:
    - name: kubeconfig
      secret:
        secretName: kubeconfig-{{inputs.parameters.environment}}
        defaultMode: 0400

  # E2E test execution
  - name: execute-e2e-tests
    inputs:
      parameters:
      - name: environment
      - name: app-name
      - name: app-version
      - name: image-url
    script:
      image: quay.io/openshift/origin-cli:latest
      command: [bash]
      env:
      - name: KUBECONFIG
        value: /tmp/kubeconfig/kubeconfig
      resources:
        limits:
          cpu: 300m
          memory: 256Mi
        requests:
          cpu: 100m
          memory: 128Mi
      volumeMounts:
      - name: kubeconfig
        mountPath: /tmp/kubeconfig
        readOnly: true
      securityContext:
        runAsNonRoot: true
        allowPrivilegeEscalation: false
        readOnlyRootFilesystem: false
        capabilities:
          drop:
          - ALL
      source: |
        set -euo pipefail
        echo "=== Running E2E Tests in {{inputs.parameters.environment}} ==="

        NAMESPACE="{{inputs.parameters.app-name}}-{{inputs.parameters.environment}}"

        # Verify kubeconfig is mounted
        if [ ! -f "${KUBECONFIG}" ]; then
          echo "‚ùå Kubeconfig not found at ${KUBECONFIG}"
          exit 1
        fi

        echo "üß™ Running E2E test suite..."

        # Test 1: Deployment readiness
        READY_REPLICAS=$(oc get deployment {{inputs.parameters.app-name}} -n "${NAMESPACE}" -o jsonpath='{.status.readyReplicas}')
        DESIRED_REPLICAS=$(oc get deployment {{inputs.parameters.app-name}} -n "${NAMESPACE}" -o jsonpath='{.spec.replicas}')

        if [ "$READY_REPLICAS" != "$DESIRED_REPLICAS" ]; then
          echo "‚ùå E2E Test Failed: Not all replicas ready ($READY_REPLICAS/$DESIRED_REPLICAS)"
          exit 1
        fi
        echo "‚úÖ Test 1 PASSED: All replicas ready ($READY_REPLICAS/$DESIRED_REPLICAS)"

        # Test 2: Pod health
        POD_NAME=$(oc get pods -n "${NAMESPACE}" -l app={{inputs.parameters.app-name}} -o jsonpath='{.items[0].metadata.name}')
        if [ -z "$POD_NAME" ]; then
          echo "‚ùå E2E Test Failed: No pods found"
          exit 1
        fi

        POD_STATUS=$(oc get pod "$POD_NAME" -n "${NAMESPACE}" -o jsonpath='{.status.phase}')
        if [ "$POD_STATUS" != "Running" ]; then
          echo "‚ùå E2E Test Failed: Pod not running ($POD_STATUS)"
          exit 1
        fi
        echo "‚úÖ Test 2 PASSED: Pod $POD_NAME is running"

        # Test 3: Configuration accessibility
        if ! oc exec -n "${NAMESPACE}" "$POD_NAME" -- cat /app/config/app.properties &>/dev/null; then
          echo "‚ùå E2E Test Failed: Configuration not accessible"
          exit 1
        fi
        echo "‚úÖ Test 3 PASSED: Configuration accessible"

        # Test 4: Service connectivity
        if ! oc get service {{inputs.parameters.app-name}} -n "${NAMESPACE}" &>/dev/null; then
          echo "‚ùå E2E Test Failed: Service not found"
          exit 1
        fi
        echo "‚úÖ Test 4 PASSED: Service available"

        # Test 5: Operator health endpoints
        echo "Testing operator health endpoints..."
        kubectl port-forward -n "${NAMESPACE}" service/{{inputs.parameters.app-name}} 8081:8081 &
        PF_PID=$!
        sleep 5

        # Test readiness probe
        if ! curl -f http://localhost:8081/readyz; then
          echo "‚ùå E2E Test Failed: Readiness probe failed"
          kill $PF_PID || true
          exit 1
        fi
        echo "‚úÖ Test 5a PASSED: Readiness probe working"

        # Test liveness probe
        if ! curl -f http://localhost:8081/healthz; then
          echo "‚ùå E2E Test Failed: Liveness probe failed"
          kill $PF_PID || true
          exit 1
        fi
        echo "‚úÖ Test 5b PASSED: Liveness probe working"

        kill $PF_PID || true

        # Test 6: CRD availability
        if ! oc get crd examples.managed.openshift.io &>/dev/null; then
          echo "‚ùå E2E Test Failed: CRD not found"
          exit 1
        fi
        echo "‚úÖ Test 6 PASSED: CRD available"

        # Test 7: Create and validate Example resource
        cat <<EOF | oc apply -f -
        apiVersion: managed.openshift.io/v1alpha1
        kind: Example
        metadata:
          name: test-example
          namespace: ${NAMESPACE}
        spec:
          message: "E2E test example"
        EOF

        # Wait for the resource to be processed
        sleep 10

        if ! oc get example test-example -n "${NAMESPACE}" &>/dev/null; then
          echo "‚ùå E2E Test Failed: Example resource not created"
          exit 1
        fi
        echo "‚úÖ Test 7 PASSED: Example resource created and processed"

        # Cleanup test resource
        oc delete example test-example -n "${NAMESPACE}" || true

        echo "üéâ All E2E tests passed in {{inputs.parameters.environment}}!"

    volumes:
    - name: kubeconfig
      secret:
        secretName: kubeconfig-{{inputs.parameters.environment}}
        defaultMode: 0400

  # Manual approval gate
  - name: manual-approval
    inputs:
      parameters:
      - name: approval-message
      - name: approver
    suspend: {}

  # Post-deployment validation
  - name: validate-deployment
    inputs:
      parameters:
      - name: environment
      - name: app-name
    script:
      image: quay.io/openshift/origin-cli:latest
      command: [bash]
      env:
      - name: KUBECONFIG
        value: /tmp/kubeconfig/kubeconfig
      resources:
        limits:
          cpu: 200m
          memory: 256Mi
        requests:
          cpu: 50m
          memory: 128Mi
      volumeMounts:
      - name: kubeconfig
        mountPath: /tmp/kubeconfig
        readOnly: true
      securityContext:
        runAsNonRoot: true
        allowPrivilegeEscalation: false
        readOnlyRootFilesystem: false
        capabilities:
          drop:
          - ALL
      source: |
        set -euo pipefail
        echo "=== Post-deployment validation in {{inputs.parameters.environment}} ==="

        NAMESPACE="{{inputs.parameters.app-name}}-{{inputs.parameters.environment}}"

        # Verify kubeconfig is mounted
        if [ ! -f "${KUBECONFIG}" ]; then
          echo "‚ùå Kubeconfig not found at ${KUBECONFIG}"
          exit 1
        fi

        # Validate deployment health
        if ! oc get deployment {{inputs.parameters.app-name}} -n "${NAMESPACE}" &>/dev/null; then
          echo "‚ùå Deployment not found"
          exit 1
        fi

        READY_REPLICAS=$(oc get deployment {{inputs.parameters.app-name}} -n "${NAMESPACE}" -o jsonpath='{.status.readyReplicas}')
        DESIRED_REPLICAS=$(oc get deployment {{inputs.parameters.app-name}} -n "${NAMESPACE}" -o jsonpath='{.spec.replicas}')

        if [ "$READY_REPLICAS" != "$DESIRED_REPLICAS" ]; then
          echo "‚ùå Post-deployment validation failed: $READY_REPLICAS/$DESIRED_REPLICAS ready"
          exit 1
        fi

        echo "‚úÖ Post-deployment validation passed!"
        echo "üìä Final deployment status:"
        oc get pods -n "${NAMESPACE}" -l app={{inputs.parameters.app-name}}

    volumes:
    - name: kubeconfig
      secret:
        secretName: kubeconfig-{{inputs.parameters.environment}}
        defaultMode: 0400

  # Notification template
  - name: send-notification
    inputs:
      parameters:
      - name: message
      - name: status
      - name: color
        value: "good"
    script:
      image: curlimages/curl:latest
      command: [sh]
      resources:
        limits:
          cpu: 100m
          memory: 64Mi
        requests:
          cpu: 10m
          memory: 32Mi
      securityContext:
        runAsNonRoot: true
        allowPrivilegeEscalation: false
        readOnlyRootFilesystem: true
        capabilities:
          drop:
          - ALL
      source: |
        set -euo pipefail
        echo "üì¢ Sending notification: {{inputs.parameters.message}}"

        # Send Slack notification if webhook is configured
        if [ -n "{{workflow.parameters.slack-webhook}}" ]; then
          echo "Sending Slack notification..."
          curl -X POST -H 'Content-type: application/json' \
            --data '{
              "text": "{{inputs.parameters.message}}",
              "attachments": [{
                "color": "{{inputs.parameters.color}}",
                "fields": [
                  {"title": "Workflow", "value": "{{workflow.name}}", "short": true},
                  {"title": "Status", "value": "{{inputs.parameters.status}}", "short": true},
                  {"title": "App", "value": "{{workflow.parameters.app-name}}", "short": true},
                  {"title": "Version", "value": "{{workflow.parameters.app-version}}", "short": true}
                ]
              }]
            }' \
            "{{workflow.parameters.slack-webhook}}" || echo "Failed to send Slack notification"
        fi

        # Send generic webhook notification if configured
        if [ -n "{{workflow.parameters.notification-webhook}}" ]; then
          echo "Sending generic webhook notification..."
          curl -X POST -H 'Content-type: application/json' \
            --data '{
              "message": "{{inputs.parameters.message}}",
              "status": "{{inputs.parameters.status}}",
              "workflow": "{{workflow.name}}",
              "app_name": "{{workflow.parameters.app-name}}",
              "app_version": "{{workflow.parameters.app-version}}"
            }' \
            "{{workflow.parameters.notification-webhook}}" || echo "Failed to send webhook notification"
        fi

        echo "‚úÖ Notification processing completed"

  # Exit handler for failure notifications
  - name: notify-on-exit
    steps:
    - - name: send-failure-notification
        template: send-notification
        arguments:
          parameters:
          - name: message
            value: "‚ùå Deployment pipeline {{workflow.status}} for {{workflow.parameters.app-name}} v{{workflow.parameters.app-version}}"
          - name: status
            value: "{{workflow.status}}"
          - name: color
            value: "danger"
        when: "{{workflow.status}} != 'Succeeded' && {{workflow.parameters.enable-notifications}} == 'true'"